var documenterSearchIndex = {"docs":
[{"location":"#SimGBS","page":"Home","title":"SimGBS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for simulating Genotyping-by-Sequencing (GBS) data.","category":"page"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimGBS provides a simple and efficient method of simulating Genotyping-by-Sequencing (GBS) data. It provides valuable resources for evaluating and developing bioinformatics pipelines and statistical methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimGBS generates GBS data from any reference genome (in FASTA format) using common restriction enzyme(s).","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimGBS defines large, complex population following the gene-drop method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimGBS samples genetic and GBS-specific variations from statistical models to reflect randomness at both individual and population level.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimGBS is capable of simulating GBS data from thousands of samples under customizable settings.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimGBS is registered in the General registry, it can be directly installed in Julia using Pkg.add   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SimGBS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SimGBS","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information about how to install Julia package, please visit Getting Started with Julia.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimGBS is designed to simulate GBS data in three simple steps:","category":"page"},{"location":"#Step-One:-Generate-GBS-Fragments","page":"Home","title":"Step One: Generate GBS Fragments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimGBS generates raw GBS fragments through in silico digestion. It cuts the reference genome into smaller fragments using common restriction enzyme(s).","category":"page"},{"location":"","page":"Home","title":"Home","text":"An optional fragment size-selection step is available to filter out GBS fragments where length falls outside the user-defined thresholds.  ","category":"page"},{"location":"#Step-Two:-Define-Population-Structure","page":"Home","title":"Step Two: Define Population Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimGBS first defines a founder population, where variants (i.e., SNPs and QTL) of each founder are sampled based on sampled allele frequencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By taking the gene drop approach , SimGBS models crossing overs between any pair of individuals, and sample recombination sites randomly across the genome. Haplotypes of their progeny can be then defined by tracking these recombination events (including the origin of maternal and parental chromosomes, as well as the recombination sites) at each generation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The demographic history of the final population can be defined by controlling the size of founder population, manipulating the growth rate of the intermediate population.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the base population becomes available, users can supply a pedigree file to generate a breeding population.  ","category":"page"},{"location":"#Step-Three:-Simulate-GBS-Process","page":"Home","title":"Step Three: Simulate GBS Process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With selected GBS fragments (after fragment size-selection) and sampled SNP positions, SimGBS can determine short haplotypes by selecting only those variants that are captured by GBS fragments and keeping GBS fragments that contains variant(s).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For each retained GBS fragment (after size-selection), two GBS reads are generated for every diploid individual based on its short haplotypes. A unique short DNA sequence (barcode, as a sample identifier) will be attached to the 5' end of each GBS read.   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To capture variation in sequencing depth, a realised depth matrix is generated by sampling per-sample and per-locus depth from independent Gamma models respectively. Both Gamma models have identical means, equal to the average total sequencing depth, and the per-locus depth model comes with larger variance than per-sample depth model, as GBS protocols have been optimised to minimise between-sample depth variations. Actual read counts of each sample at per locus basis are then drawn from a Negative Binomial distribution with mean equal to its realised depth score.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Two GBS reads generated from a single locus for each sample (i.e., each carries maternal/paternal haplotype) will share the read counts at equal chance (i.e., Binomial sampling with probability equals 0.5).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the extact copies of each GBS read become known, SimGBS replicates each GBS read at the specified level. A header, which stores the information of sequencing, and a string of quality scores are then added to each GBS read to generate a GBS sequence. All simulated GBS reads are in FASTQ format.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once installed, we can import SimGBS in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SimGBS","category":"page"},{"location":"#Required-Input","page":"Home","title":"Required Input","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following files are required for running SimGBS   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A compressed reference genome (e.g., ref.fa.gz)\nGBS barcodes (e.g., GBS_Barcodes.txt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To help users with testing SimGBS, an example script and associated input files can be found on GitHub or figshare.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that input files must be stored in the working directory, please use the following commands to check/change your current working directory","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> pwd()\njulia> cd()","category":"page"},{"location":"#Usage-and-Options","page":"Home","title":"Usage and Options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main functionalities of SimGBS have been organised into three wrapper functions, where each function corresponds to one step as described in the previous section.","category":"page"},{"location":"#Step-One:-Generate-GBS-Fragments-2","page":"Home","title":"Step One: Generate GBS Fragments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"digestGenome(genofile::String, re::Array{restrictionEnzyme,1}, useChr::Array{Int64}, useChrLen::Array{Float64}, lowerThresh::Int64, upperThresh::Int64, winSize::Int64, plotOutput::Bool , writeOutput::Bool)","category":"page"},{"location":"#SimGBS.digestGenome-Tuple{String, Vector{restrictionEnzyme}, Array{Int64, N} where N, Array{Float64, N} where N, Int64, Int64, Int64, Bool, Bool}","page":"Home","title":"SimGBS.digestGenome","text":"digestGenome(genofile, re, useChr, useChrLen, lower ,upper, plotOutput, writeOutput)\n\nPerform virtual digestion using restriction enzyme and generate GBS fragments.\n\nThis function uses specified restriction enzyme(s) to digest genome and therefore generate GBS fragments. Fragment size-selection step is also included.\n\nArguments\n\ngenofile: file containing the reference genome\nre: restriction enzyme(s) to be used\nuseChr: either the number of chromosome or a set of chromosome(s) to be simulated\nuseChrLen: length of chromosome in cM to be used in simulation, otherwise using entire chromosome\nlower: lower threshold of fragment size-selection\nupper: upper threshold of fragment size-selection\nwinSize: size of window used for calculating average genomic coverage\nplotOutput: set to true if graphical outputs are required\nwriteOutput: set to true if text outputs are required\n\n...\n\nExamples\n\njulia> digestGenome(\"ref.fa.gz\", [SimGBS.ApeKI], [1], Array{Float64}(undef,0), 65 ,195, 1000000, false, true)\n\n\n\n\n\n","category":"method"},{"location":"#Step-Two:-Define-Population-Structure-2","page":"Home","title":"Step Two: Define Population Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"definePopulation(numFounders::Int64, endSize::Int64, numGenCha::Int64, numGenCon::Int64, numGenFinal::Int64, numInd::Int64, useWeights::Array{Float64}, usePedigree::Bool, pedFile::String, pedOutput::Bool)","category":"page"},{"location":"#SimGBS.definePopulation-Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Array{Float64, N} where N, Bool, String, Bool}","page":"Home","title":"SimGBS.definePopulation","text":"definePopulation(numFounders, endSize, numGenCha, numGenCon, numGenFinal, numInd, useWeights, usePedigree, pedFile, pedOutput);\n\nCreate population structure for simulation.\n\nThis function generates different population structure, and there is an option to follow a user-defined pedigree.\n\nArguments\n\nnumFounders: number of founders in the base population\nendSize: number of individuals to end up in the changingPopSize step\nnumInd: number of individuals to be simulated\nnumGenCha: number of generations for changingPopSize function\nnumGenCon: number of generations for constantPopSize function\nnumGenFinal: number of final generations to be used to select individual\nuseWeights: weights of each contributing genetarion in the final population composition\nusePedigree: set to false if you don't use pedigree, otherwise specify the pedigree file to be used\npedFile: pedigree file\npedOutput: set to true if return pedigree output\n\nNotes\n\nPlease consider modifyin the combination of constant and changing population (as well as combining multiple populations) when defining complicated population structure.\n\nExamples\n\njulia> definePopulation(100, 500, 20, 100, 4, 96,  Array{Float64}(undef,0), false, \"sim.ped\", false);\n\n\n\n\n\n","category":"method"},{"location":"#Step-Three:-Simulate-GBS-Process-2","page":"Home","title":"Step Three: Simulate GBS Process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GBS(totalQTL::Int64, totalSNP::Int64, muSNPdensity::Float64, sigmasqSNPdensity::Float64, winSize::Int64, muAlleleFreq::Float64,sigmasqAlleleFreq::Float64, re, meanDepth::Float64, barcodeFile::String,useChr::Array{Int64}, plotOutput::Bool, writeOutput::Bool,onlyOutputGBS::Bool)","category":"page"},{"location":"#SimGBS.GBS-Tuple{Int64, Int64, Float64, Float64, Int64, Float64, Float64, Any, Float64, String, Array{Int64, N} where N, Bool, Bool, Bool}","page":"Home","title":"SimGBS.GBS","text":"GBS(totalQTL, totalSNP, muDensity, sigmasqDensity, winSize, muAlleleFreq, sigmasqAlleleFreq, re, meanDepth, barcodeFile, useChr, plotOutput, writeOutput, onlyOutputGBS)\n\nSimulate Genotyping-by-Sequencing (GBS) data.\n\nThis function generates GBS reads by inserting genomic variants into in silico digested genomic fragments, ligates the polymorphic sequence with barcodes and replicates based on sequencing depth.\n\nArguments\n\ntotalQTL: total number of QTL to be simulated\ntotalSNP: total number of SNPs to be simulated (set to \"0\" if sampling SNP positions based on density)\nmuDensity: location parameter of log-Laplace distribution (for sampling SNP density)\nsigmasqDensity: scale parameter of log-Laplace distribution (for sampling SNP density)\nwinSize: Size of window and bin for sampling SNP positions\nmuAlleleFreq: mean of sampled allele frequency\nsigmasqAlleleFreq: variance of sampled allele frequency\nre: restriction enzyme(s) to be used\nbarcodeFile: file containing GBS barcodes\nuseChr: either the number of chromosomes or a set of chromosome(s) to be simulated\nplotOutput: set to true if graphical outputs are required\nwriteOutput: set to true if text outputs are required\nonlyOutputGBS: set to true if only GBS data is kept\n\nExamples\n\njulia> GBS(100, 0, -2.0, 0.001, 1000000, 0.5, 0.001, [SimGBS.ApeKI], 20.0, \"GBS_Barcodes.txt\", [1], false, true, true)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"After importing SimGBS, users can execute all three functions sequentially to generate GBS data. Alternatively, users may run the Julia script directly","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia example.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that each function can also be executed independently to carry out specific task (e.g., run digestGenome for testing GBS coverage under different choice of restriction enzyme).","category":"page"},{"location":"#Expected-Output","page":"Home","title":"Expected Output","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Following outputs will be returned ","category":"page"},{"location":"#GBS-Fragments","page":"Home","title":"GBS Fragments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RawFrag.txt: raw GBS fragments following in silico digestion\nGBSFrag.txt: selected GBS fragments after fragment size-selection\nGBSCoverage.txt: genomic coverage of GBS fragments\nsnpFragGBS.txt: GBS fragments that contain SNPs","category":"page"},{"location":"#Variants","page":"Home","title":"Variants","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"qtlGeno.txt: QTL genotype matrix (number of individual x number of QTL)\nsnpGeno.txt: SNP genotype matrix (number of individual x number of SNP)\nqtlInfo.txt: information about QTL, including chromosome, position and allele frequency","category":"page"},{"location":"","page":"Home","title":"Home","text":"QTL ID Chromosome Position Sampled Allele Frequnecy\nQTL_1 1 2064912 0.003\nQTL_2 1 3088811 0.15\nQTL_3 1 4974206 0.36","category":"page"},{"location":"","page":"Home","title":"Home","text":"snpInfo.txt: information about SNPs, including chromosome, position and allele frequency","category":"page"},{"location":"","page":"Home","title":"Home","text":"SNP ID Chromosome Position Sampled Allele Frequnecy\nSNP_1 1 109078 0.27\nSNP_2 1 109083 0.02\nSNP_3 1 247119 0.07","category":"page"},{"location":"","page":"Home","title":"Home","text":"shortHap.txt: a (number of haplotypes (2 x number of individuals for diploid species) x number of SNP) matrix of short haplotypes generated by GBS fragments (i.e., SNPs captured within each GBS fragment)\nreadDepth.txt: a (number of individuals x number of SNP) matrix records the number of copies per GBS fragment  ","category":"page"},{"location":"#GBS-Data","page":"Home","title":"GBS Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"keyFile\\_ABC12AAXX\\_1.txt: pseudo-information about GBS sample, e.g.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Flowcell Lane Barcode Sample Name Plate Row Column\nABC12AAXX 1 CCAATCAGA Ind_1 Plate1 A 1\nABC12AAXX 1 CCAATCAGA Ind_2 Plate1 A 2\nABC12AAXX 1 CCAATCAGA Ind_3 Plate1 A 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"ABC12AAXX\\_1\\_fastq.txt.gz: simulated GBS sequences","category":"page"},{"location":"#What's-Next?","page":"Home","title":"What's Next?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following tools are recommended for downstream analyses of GBS data,","category":"page"},{"location":"","page":"Home","title":"Home","text":"snpGBS: a simple bioinformatics workflow to identify single nucleotide polymorphism (SNP) from Genotyping-by-Sequencing (GBS) data.\nKGD: R code for the analysis of genotyping-by-sequencing (GBS) data, primarily to construct a genomic relationship matrix for the genotyped individuals.   \nGUSLD: An R package for estimating linkage disequilibrium using low and/or high coverage sequencing data without requiring filtering with respect to read depth.\nSMAP a software package that analyzes read mapping distributions and performs haplotype calling to create multi-allelic molecular markers.","category":"page"}]
}
