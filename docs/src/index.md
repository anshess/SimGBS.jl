# SimGBS

A Julia package for simulating Genotyping-by-Sequencing (GBS) data.

## Highlights

SimGBS provides a simple and efficient method of simulating [Genotyping-by-Sequencing (GBS)](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0019379) data. It provides valuable resources for evaluating and developing bioinformatics pipelines and statistical methods.

SimGBS generates GBS data from any reference genome (in FASTA format) using common [restriction enzyme(s)](https://en.wikipedia.org/wiki/Restriction_enzyme#Examples).

SimGBS defines large, complex population following the [gene-drop](https://academic.oup.com/g3journal/article/5/7/1415/6025367) method.

SimGBS samples genetic and GBS-specific variations from statistical models to reflect randomness at both individual and population level.

SimGBS is capable of simulating GBS data from thousands of samples under customizable settings.


## Installation

SimGBS is registered in the [`General`](https://github.com/JuliaRegistries/General) registry, it can be directly installed in [`Julia`](https://julialang.org/) using [`Pkg.add`](https://docs.julialang.org/en/v1/stdlib/Pkg/)   

```{julia}
julia> using Pkg
julia> Pkg.add("SimGBS")
```
or

```julia
julia> ]
pkg> add SimGBS
```

For more information about how to install Julia package, please visit [Getting Started with Julia](https://julialang.org/learning/getting-started/#getting_started_with_julia).


## Overview

SimGBS is designed to simulate GBS data in three simple steps:

#### Step One: Generate GBS Fragments

SimGBS generates raw GBS fragments through _in silico_ digestion. It cuts the reference genome into smaller fragments using common restriction enzyme(s).

An optional fragment size-selection step is available to filter out GBS fragments where length falls outside the user-defined thresholds.  

#### Step Two: Define Population Structure

SimGBS first defines a founder population, where variants (i.e., SNPs and QTL) of each founder are sampled based on sampled allele frequencies.

By taking the gene drop approach , SimGBS models crossing overs between any pair of individuals, and sample recombination sites randomly across the genome. Haplotypes of their progeny can be then defined by tracking these recombination events (including the origin of maternal and parental chromosomes, as well as the recombination sites) at each generation.

The demographic history of the final population can be defined by controlling the size of founder population, manipulating the growth rate of the intermediate population.

Once the base population becomes available, users can supply a pedigree file to generate a breeding population.  

#### Step Three: Simulate GBS Process

With selected GBS fragments (after fragment size-selection) and sampled SNP positions, SimGBS can determine short haplotypes by selecting only those variants that are captured by GBS fragments and keeping GBS fragments that contains variant(s).

For each retained GBS fragment (after size-selection), two GBS reads are generated for every diploid individual based on its short haplotypes. A unique short DNA sequence (barcode, as a sample identifier) will be attached to the 5' end of each GBS read.   

To capture variation in sequencing depth, a realised depth matrix is generated by sampling per-sample and per-locus depth from independent Gamma models respectively. Both Gamma models have identical means, equal to the average total sequencing depth, and the per-locus depth model comes with larger variance than per-sample depth model, as GBS protocols have been optimised to minimise between-sample depth variations. Actual read counts of each sample at per locus basis are then drawn from a Negative Binomial distribution with mean equal to its realised depth score.

Two GBS reads generated from a single locus for each sample (i.e., each carries maternal/paternal haplotype) will share the read counts at equal chance (i.e., Binomial sampling with probability equals 0.5).

Once the extact copies of each GBS read become known, SimGBS replicates each GBS read at the specified level. A header, which stores the information of sequencing, and a string of quality scores are then added to each GBS read to generate a GBS sequence. All simulated GBS reads are in [FASTQ](https://en.wikipedia.org/wiki/FASTQ_format) format.


## Getting Started

Once installed, we can import SimGBS in Julia

```julia
julia> using SimGBS
```

### Required Input

The following files are required for running SimGBS   

- A compressed reference genome (e.g., ref.fa.gz)

- GBS barcodes (e.g., GBS_Barcodes.txt)

To help users with testing SimGBS, an example script and associated input files can be found on [GitHub](https://github.com/kanji709/SimGBS.jl/tree/master/example) or [figshare](https://figshare.com/articles/dataset/SimGBS_jl/14672343).  

Note that input files must be stored in the working directory, please use the following commands to check/change your current working directory
```julia
julia> pwd()
julia> cd()
```

### Usage and Options

The main functionalities of SimGBS have been organised into three wrapper functions, where each function corresponds to one step as described in the previous section.


#### Step One: Generate GBS Fragments

```@docs
digestGenome(genofile::String, re::Array{restrictionEnzyme,1}, useChr::Array{Int64}, useChrLen::Array{Float64}, lowerThresh::Int64, upperThresh::Int64, winSize::Int64, plotOutput::Bool , writeOutput::Bool)
```

#### Step Two: Define Population Structure

```@docs
definePopulation(numFounders::Int64, endSize::Int64, numGenCha::Int64, numGenCon::Int64, numGenFinal::Int64, numInd::Int64, useWeights::Array{Float64}, usePedigree::Bool, pedFile::String, pedOutput::Bool)
```

#### Step Three: Simulate GBS Process

```@docs
GBS(totalQTL::Int64, totalSNP::Int64, muSNPdensity::Float64, sigmasqSNPdensity::Float64, winSize::Int64, muAlleleFreq::Float64,sigmasqAlleleFreq::Float64, re, meanDepth::Float64, barcodeFile::String,useChr::Array{Int64}, plotOutput::Bool, writeOutput::Bool,onlyOutputGBS::Bool)
```

After importing SimGBS, users can execute all three functions sequentially to generate GBS data. Alternatively, users may run the Julia script directly

```{bash}
$ julia example.jl
```

Note that each function can also be executed independently to carry out specific task (e.g., run `digestGenome` for testing GBS coverage under different choice of restriction enzyme).


## Expected Output

Following outputs will be returned 

#### GBS Fragments
- RawFrag.txt: raw GBS fragments following _in silico_ digestion
- GBSFrag.txt: selected GBS fragments after fragment size-selection
- GBSCoverage.txt: genomic coverage of GBS fragments
- snpFragGBS.txt: GBS fragments that contain SNPs

#### Variants
- `qtlGeno.txt`: QTL genotype matrix (number of individual x number of QTL)
- `snpGeno.txt`: SNP genotype matrix (number of individual x number of SNP)
- `qtlInfo.txt`: information about QTL, including chromosome, position and allele frequency


| QTL ID        | Chromosome  | Position  | Sampled Allele Frequnecy   | 
| ------------- |-------------| ----------| ---------------------------| 
| QTL_1         | 1           | 2064912   | 0.003                      |
| QTL_2         | 1           | 3088811   | 0.15                       |  
| QTL_3         | 1           | 4974206   | 0.36                       |  

- `snpInfo.txt`: information about SNPs, including chromosome, position and allele frequency


| SNP ID        | Chromosome  | Position  | Sampled Allele Frequnecy   | 
| ------------- |-------------| ----------| ---------------------------| 
| SNP_1         | 1           | 109078    | 0.27                       |
| SNP_2         | 1           | 109083    | 0.02                       |  
| SNP_3         | 1           | 247119    | 0.07                       | 

- `shortHap.txt`: a (number of haplotypes (2 x number of individuals for diploid species) x number of SNP) matrix of short haplotypes generated by GBS fragments (i.e., SNPs captured within each GBS fragment)

- `readDepth.txt`: a (number of individuals x number of SNP) matrix records the number of copies per GBS fragment  

#### GBS Data
- `keyFile\_ABC12AAXX\_1.txt`: pseudo-information about GBS sample, e.g.  


| Flowcell      | Lane        | Barcode   | Sample Name   | Plate       | Row | Column | 
| ------------- |-------------| ----------| ------------- |-------------| ----| ------ |
| ABC12AAXX     | 1           | CCAATCAGA | Ind_1         | Plate1      | A   | 1      |
| ABC12AAXX     | 1           | CCAATCAGA | Ind_2         | Plate1      | A   | 2      |
| ABC12AAXX     | 1           | CCAATCAGA | Ind_3         | Plate1      | A   | 3      |

 
 - `ABC12AAXX\_1\_fastq.txt.gz`: simulated GBS sequences


## What's Next?

The following tools are recommended for downstream analyses of GBS data,

- [**snpGBS**](https://github.com/AgResearch/snpGBS): a simple bioinformatics workflow to identify single nucleotide polymorphism (SNP) from Genotyping-by-Sequencing (GBS) data.

- [**KGD**](https://github.com/AgResearch/KGD): R code for the analysis of genotyping-by-sequencing (GBS) data, primarily to construct a genomic relationship matrix for the genotyped individuals.   

- [**GUSLD**](https://github.com/AgResearch/GUS-LD): An R package for estimating linkage disequilibrium using low and/or high coverage sequencing data without requiring filtering with respect to read depth.

- [**SMAP**](https://gitlab.com/truttink/smap) a software package that analyzes read mapping distributions and performs haplotype calling to create multi-allelic molecular markers.
